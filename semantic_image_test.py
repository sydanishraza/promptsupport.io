#!/usr/bin/env python3
"""
FINAL VERIFICATION - SEMANTIC IMAGE PLACEMENT SYSTEM TESTING
Testing the enhanced semantic image placement system to verify the user's reported issue is resolved:
"Every article generated by the system includes all images from the source document, but there is no contextual placement or distribution of those images across the appropriate sections of the articles."
"""

import asyncio
import json
import os
import sys
import uuid
import tempfile
import shutil
from datetime import datetime
from typing import List, Dict, Any
import requests
import time

# Add the backend directory to the Python path
sys.path.append('/app/backend')

# Import the functions we need to test
try:
    from server import (
        apply_semantic_image_placement,
        calculate_comprehensive_similarity,
        create_semantic_image_html,
        insert_image_at_appropriate_position,
        create_documentation_articles_from_content
    )
    print("✅ Successfully imported semantic image placement functions")
except ImportError as e:
    print(f"❌ Failed to import functions: {e}")
    sys.exit(1)

# Configuration
BACKEND_URL = "https://promptsupport-3.preview.emergentagent.com/api"

class SemanticImagePlacementTester:
    """Comprehensive tester for the semantic image placement system"""
    
    def __init__(self):
        self.test_results = []
        self.backend_url = BACKEND_URL
        
    def log_test(self, test_name: str, passed: bool, details: str):
        """Log test results"""
        status = "✅ PASS" if passed else "❌ FAIL"
        print(f"{status} {test_name}: {details}")
        self.test_results.append({
            "test": test_name,
            "passed": passed,
            "details": details,
            "timestamp": datetime.now().isoformat()
        })
    
    async def test_calculate_comprehensive_similarity(self):
        """Test the enhanced similarity scoring system"""
        print("\n🧪 TESTING: calculate_comprehensive_similarity function")
        
        # Test 1: Jaccard similarity calculation
        text1 = "product management guide configuration settings"
        text2 = "product configuration management system settings guide"
        
        similarity = calculate_comprehensive_similarity(text1, text2)
        
        # Should have high similarity due to word overlap
        if similarity > 0.5:
            self.log_test("Jaccard Similarity Calculation", True, f"High similarity score: {similarity:.3f}")
        else:
            self.log_test("Jaccard Similarity Calculation", False, f"Low similarity score: {similarity:.3f}")
        
        # Test 2: Important terms matching
        text1 = "database configuration parameters"
        text2 = "database setup configuration options"
        
        similarity = calculate_comprehensive_similarity(text1, text2)
        
        if similarity > 0.3:
            self.log_test("Important Terms Matching", True, f"Terms matched with score: {similarity:.3f}")
        else:
            self.log_test("Important Terms Matching", False, f"Terms not matched properly: {similarity:.3f}")
        
        # Test 3: Phrase matching
        text1 = "user interface design patterns"
        text2 = "design patterns for user interface development"
        
        similarity = calculate_comprehensive_similarity(text1, text2)
        
        if similarity > 0.2:
            self.log_test("Phrase Matching", True, f"Phrases matched with score: {similarity:.3f}")
        else:
            self.log_test("Phrase Matching", False, f"Phrases not matched: {similarity:.3f}")
        
        # Test 4: No similarity case
        text1 = "database configuration"
        text2 = "weather forecast sunny"
        
        similarity = calculate_comprehensive_similarity(text1, text2)
        
        if similarity < 0.1:
            self.log_test("No Similarity Detection", True, f"Correctly detected no similarity: {similarity:.3f}")
        else:
            self.log_test("No Similarity Detection", False, f"False positive similarity: {similarity:.3f}")
    
    def test_create_semantic_image_html(self):
        """Test HTML image creation"""
        print("\n🧪 TESTING: create_semantic_image_html function")
        
        # Test image data
        test_image = {
            "url": "/api/static/uploads/session_123/test_image.png",
            "alt_text": "Product Configuration Diagram",
            "caption": "Figure 1: Product configuration workflow"
        }
        
        html_result = create_semantic_image_html(test_image)
        
        # Verify HTML structure
        required_elements = [
            '<figure style="margin: 20px 0; text-align: center;">',
            '<img src="/api/static/uploads/session_123/test_image.png"',
            'alt="Product Configuration Diagram"',
            '<figcaption',
            'Figure 1: Product configuration workflow',
            '</figure>'
        ]
        
        all_present = all(element in html_result for element in required_elements)
        
        if all_present:
            self.log_test("Semantic Image HTML Creation", True, "All required HTML elements present")
        else:
            missing = [elem for elem in required_elements if elem not in html_result]
            self.log_test("Semantic Image HTML Creation", False, f"Missing elements: {missing}")
    
    def test_insert_image_at_appropriate_position(self):
        """Test contextual image placement within content"""
        print("\n🧪 TESTING: insert_image_at_appropriate_position function")
        
        # Test content with multiple paragraphs
        test_content = """<h1>Product Management Guide</h1>
<p>This is the first paragraph introducing the topic.</p>
<p>This is the second paragraph with more detailed information about the product management process.</p>
<h2>Configuration Settings</h2>
<p>This paragraph discusses configuration settings in detail.</p>
<p>Additional information about configuration parameters.</p>"""
        
        test_image_html = '<figure><img src="test.png" alt="Test Image"><figcaption>Test Caption</figcaption></figure>'
        
        result = insert_image_at_appropriate_position(test_content, test_image_html)
        
        # Image should be inserted after the second paragraph, not at the beginning or end
        if test_image_html in result:
            # Check that image is not at the very beginning
            if not result.startswith(test_image_html):
                # Check that image is positioned contextually
                if result.find(test_image_html) > result.find("</p>"):
                    self.log_test("Contextual Image Placement", True, "Image placed after content, not at beginning")
                else:
                    self.log_test("Contextual Image Placement", False, "Image placed at beginning instead of contextually")
            else:
                self.log_test("Contextual Image Placement", False, "Image placed at very beginning of content")
        else:
            self.log_test("Contextual Image Placement", False, "Image not inserted into content")
    
    async def test_apply_semantic_image_placement(self):
        """Test the core semantic image placement algorithm"""
        print("\n🧪 TESTING: apply_semantic_image_placement function")
        
        # Create test articles data
        articles_data = {
            "overview": {
                "title": "System Overview",
                "content": "<h1>System Overview</h1><p>General system information and navigation.</p>",
                "summary": "Overview of the system"
            },
            "articles": [
                {
                    "title": "Product Configuration Guide",
                    "content": "<h1>Product Configuration</h1><p>This article covers product configuration settings, parameters, and management workflows.</p>",
                    "summary": "Guide for configuring products and managing settings"
                },
                {
                    "title": "User Interface Design",
                    "content": "<h1>User Interface Design</h1><p>This article discusses user interface design patterns, layouts, and visual elements.</p>",
                    "summary": "Design guidelines for user interfaces"
                },
                {
                    "title": "Database Management",
                    "content": "<h1>Database Management</h1><p>This article covers database operations, queries, and data management procedures.</p>",
                    "summary": "Database management and operations"
                }
            ]
        }
        
        # Create test images with different contexts
        contextual_images = [
            {
                "id": "img_1",
                "filename": "product_config.png",
                "url": "/api/static/uploads/session_123/product_config.png",
                "alt_text": "Product Configuration Screen",
                "caption": "Product configuration interface",
                "semantic_context": "product configuration settings parameters management",
                "confidence_score": 0.8
            },
            {
                "id": "img_2", 
                "filename": "ui_design.png",
                "url": "/api/static/uploads/session_123/ui_design.png",
                "alt_text": "User Interface Layout",
                "caption": "UI design mockup",
                "semantic_context": "user interface design layout visual elements",
                "confidence_score": 0.7
            },
            {
                "id": "img_3",
                "filename": "database_schema.png", 
                "url": "/api/static/uploads/session_123/database_schema.png",
                "alt_text": "Database Schema Diagram",
                "caption": "Database structure diagram",
                "semantic_context": "database schema tables relationships queries",
                "confidence_score": 0.9
            },
            {
                "id": "img_4",
                "filename": "generic_chart.png",
                "url": "/api/static/uploads/session_123/generic_chart.png", 
                "alt_text": "Generic Chart",
                "caption": "Statistical chart",
                "semantic_context": "chart statistics data visualization",
                "confidence_score": 0.3
            }
        ]
        
        # Apply semantic image placement
        result_data = await apply_semantic_image_placement(articles_data, contextual_images)
        
        # Test 1: Verify each image appears in only one article
        all_assigned_images = []
        
        # Check overview
        if 'assigned_images' in result_data.get('overview', {}):
            all_assigned_images.extend(result_data['overview']['assigned_images'])
        
        # Check articles
        for article in result_data.get('articles', []):
            if 'assigned_images' in article:
                all_assigned_images.extend(article['assigned_images'])
        
        # Check for duplicates
        unique_images = set(all_assigned_images)
        if len(all_assigned_images) == len(unique_images):
            self.log_test("No Image Duplication", True, f"All {len(all_assigned_images)} images assigned uniquely")
        else:
            duplicates = len(all_assigned_images) - len(unique_images)
            self.log_test("No Image Duplication", False, f"{duplicates} duplicate image assignments found")
        
        # Test 2: Verify semantic matching worked
        # Product config image should go to product config article
        product_article = None
        for i, article in enumerate(result_data.get('articles', [])):
            if 'product' in article['title'].lower() and 'configuration' in article['title'].lower():
                product_article = article
                break
        
        if product_article and 'assigned_images' in product_article:
            if 'img_1' in product_article['assigned_images']:
                self.log_test("Semantic Matching - Product Config", True, "Product config image assigned to product config article")
            else:
                self.log_test("Semantic Matching - Product Config", False, "Product config image not assigned to relevant article")
        else:
            self.log_test("Semantic Matching - Product Config", False, "Product config article not found or no images assigned")
        
        # Test 3: Verify low-relevance images go to overview
        overview_images = result_data.get('overview', {}).get('assigned_images', [])
        if 'img_4' in overview_images:  # Generic chart should go to overview due to low relevance
            self.log_test("Low-Relevance Fallback", True, "Low-relevance image assigned to overview")
        else:
            self.log_test("Low-Relevance Fallback", False, "Low-relevance image not assigned to overview fallback")
        
        # Test 4: Verify images are embedded in content
        total_embedded_images = 0
        for article in result_data.get('articles', []):
            if '<figure' in article.get('content', ''):
                total_embedded_images += article['content'].count('<figure')
        
        if 'overview' in result_data and '<figure' in result_data['overview'].get('content', ''):
            total_embedded_images += result_data['overview']['content'].count('<figure')
        
        if total_embedded_images > 0:
            self.log_test("Images Embedded in Content", True, f"{total_embedded_images} images embedded in article content")
        else:
            self.log_test("Images Embedded in Content", False, "No images found embedded in article content")
        
        return result_data
    
    async def test_end_to_end_docx_processing(self):
        """Test end-to-end DOCX processing with semantic image placement"""
        print("\n🧪 TESTING: End-to-End DOCX Processing")
        
        # Create a test DOCX file content (simulated)
        test_docx_content = """
        Product Management Guide
        
        Configuration Settings
        This section explains how to configure products in the system. The configuration interface allows you to set various parameters and options.
        
        User Management
        This section covers user account management, permissions, and access control features.
        
        Reporting Features  
        This section describes the reporting capabilities and how to generate various types of reports.
        """
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write(test_docx_content)
            temp_file_path = f.name
        
        try:
            # Test file upload via API
            files = {'file': ('test_document.docx', open(temp_file_path, 'rb'), 'application/vnd.openxmlformats-officedocument.wordprocessingml.document')}
            
            response = requests.post(f"{self.backend_url}/content/upload", files=files, timeout=60)
            
            if response.status_code == 200:
                result = response.json()
                
                if result.get('success'):
                    self.log_test("DOCX Upload Processing", True, f"File processed successfully")
                    
                    # Check if articles were created
                    if 'articles_created' in result:
                        articles_count = result.get('articles_created', 0)
                        if articles_count > 0:
                            self.log_test("Article Generation", True, f"{articles_count} articles generated")
                        else:
                            self.log_test("Article Generation", False, "No articles generated")
                    
                    # Check if images were processed
                    if 'images_processed' in result:
                        images_count = result.get('images_processed', 0)
                        self.log_test("Image Processing", images_count >= 0, f"{images_count} images processed")
                    
                else:
                    self.log_test("DOCX Upload Processing", False, f"Processing failed: {result.get('error', 'Unknown error')}")
            else:
                self.log_test("DOCX Upload Processing", False, f"HTTP {response.status_code}: {response.text}")
                
        except Exception as e:
            self.log_test("End-to-End DOCX Processing", False, f"Error: {str(e)}")
        finally:
            # Clean up
            if os.path.exists(temp_file_path):
                os.unlink(temp_file_path)
    
    async def test_content_library_integration(self):
        """Test that articles are properly stored in Content Library"""
        print("\n🧪 TESTING: Content Library Integration")
        
        try:
            # Get articles from Content Library
            response = requests.get(f"{self.backend_url}/content-library", timeout=30)
            
            if response.status_code == 200:
                articles = response.json()
                
                if isinstance(articles, list) and len(articles) > 0:
                    self.log_test("Content Library Access", True, f"Found {len(articles)} articles in Content Library")
                    
                    # Check for articles with images
                    articles_with_images = 0
                    total_images = 0
                    
                    for article in articles[:10]:  # Check first 10 articles
                        content = article.get('content', '')
                        if '<figure' in content or '<img' in content:
                            articles_with_images += 1
                            total_images += content.count('<figure') + content.count('<img')
                    
                    if articles_with_images > 0:
                        self.log_test("Articles with Images", True, f"{articles_with_images} articles contain {total_images} images")
                    else:
                        self.log_test("Articles with Images", False, "No articles found with embedded images")
                        
                else:
                    self.log_test("Content Library Access", False, "No articles found in Content Library")
            else:
                self.log_test("Content Library Access", False, f"HTTP {response.status_code}: {response.text}")
                
        except Exception as e:
            self.log_test("Content Library Integration", False, f"Error: {str(e)}")
    
    def print_summary(self):
        """Print test summary"""
        print("\n" + "="*80)
        print("🎯 SEMANTIC IMAGE PLACEMENT SYSTEM TEST SUMMARY")
        print("="*80)
        
        total_tests = len(self.test_results)
        passed_tests = sum(1 for result in self.test_results if result['passed'])
        failed_tests = total_tests - passed_tests
        
        print(f"Total Tests: {total_tests}")
        print(f"✅ Passed: {passed_tests}")
        print(f"❌ Failed: {failed_tests}")
        print(f"Success Rate: {(passed_tests/total_tests)*100:.1f}%")
        
        if failed_tests > 0:
            print(f"\n❌ FAILED TESTS:")
            for result in self.test_results:
                if not result['passed']:
                    print(f"   - {result['test']}: {result['details']}")
        
        print("\n🎯 CRITICAL VERIFICATION RESULTS:")
        
        # Check specific requirements from the review request
        semantic_matching_passed = any("Semantic Matching" in r['test'] and r['passed'] for r in self.test_results)
        no_duplication_passed = any("No Image Duplication" in r['test'] and r['passed'] for r in self.test_results)
        contextual_placement_passed = any("Contextual Image Placement" in r['test'] and r['passed'] for r in self.test_results)
        
        print(f"✅ Semantic Image Assignment: {'WORKING' if semantic_matching_passed else 'FAILED'}")
        print(f"✅ No Image Duplication: {'WORKING' if no_duplication_passed else 'FAILED'}")
        print(f"✅ Contextual Placement: {'WORKING' if contextual_placement_passed else 'FAILED'}")
        
        # Overall assessment
        critical_tests_passed = semantic_matching_passed and no_duplication_passed and contextual_placement_passed
        
        if critical_tests_passed:
            print(f"\n🎉 CRITICAL SUCCESS: The user's reported issue appears to be RESOLVED")
            print(f"   Images are now distributed based on semantic relevance, not duplicated across all articles")
        else:
            print(f"\n❌ CRITICAL FAILURE: The user's reported issue is NOT fully resolved")
            print(f"   Images may still be appearing in all articles or not properly distributed")
        
        return passed_tests, failed_tests, critical_tests_passed

async def main():
    """Run all semantic image placement tests"""
    print("🚀 STARTING SEMANTIC IMAGE PLACEMENT SYSTEM TESTING")
    print("="*80)
    print("OBJECTIVE: Verify that the enhanced semantic image placement system")
    print("completely resolves the user's reported issue:")
    print('"Every article generated by the system includes all images from the source document,')
    print('but there is no contextual placement or distribution of those images across the')
    print('appropriate sections of the articles."')
    print("="*80)
    
    tester = SemanticImagePlacementTester()
    
    # Run all tests
    await tester.test_calculate_comprehensive_similarity()
    tester.test_create_semantic_image_html()
    tester.test_insert_image_at_appropriate_position()
    await tester.test_apply_semantic_image_placement()
    await tester.test_end_to_end_docx_processing()
    await tester.test_content_library_integration()
    
    # Print summary
    passed, failed, critical_success = tester.print_summary()
    
    return critical_success

if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)